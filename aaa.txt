 pre::stepFunc calibJapanTheta = isTest ? sRTheta : japanIRCalculator_nonCalib.getHWTheta(japanDF , vbondRA); // take a long time!!!!
========================================================================================== const pre::stepFunc IR::getHWTheta(  std::vector< std::pair<int, double> > DFs,  std::vector<double>& _bondA  )  {  std::vector<double> theta(1,0.);  std::vector<double> year(1,0.) ;//  = file::Converter::extactFirst(DFs)/365;
  std::vector<double> vbondA(1,0.);  //const std::vector<double> time = this->_sa._a;  const std::vector<int>    time   = file::Converter::extactFirst(DFs);  const std::vector<double> disFac = file::Converter::extactSecond(DFs);
  //  for (std::size_t i = 0; i < time.size()-1; ++i) {  //   pre::stepFunc iret(year,theta);   //   double time1 = i/365.;   //   double time2 = (i+1)/365.;  //   double a  = this->_sa.getValue(time1);  //   double vol= this->_svol.getValue(time1);//stepFunc.~~~~;  //   double bond = disFac.at(i+1);//Reader.~~~~;  //   //double itheta = calibHWTheta_t1t2(  //   // bootstrapA_0_t1,   //   // a,   //   // vol,   //   // bond,  //   // time1 ,  //   // time2 ,  //   // this->_r0 );  //  //   if(i>100)break;  //   COUT(i);  //   //COUT(disFac.at(i));  //  //   double itheta = calibHWTheta_t1t2(  //    iret,   //    bond,  //    time1 ,  //    time2-time1,  //    DFs.at(DFs.size()-1).first /365.  //    );  //   //const double C_0_T2 = (1 - std::exp(-1 * a* time2 )) / a;  //   //const double bondT2 = DFs.at(i+1).second;  //   //bootstrapA_0_t1 = -1 * std::log(bondT2)  -1 * this->_r0 * C_0_T2;  //   theta.push_back(itheta);  //   year.push_back(time1);  //  ////  ////   if(i>10) continue;  ////   //if(i%100!=0) continue;  ////   COUT("----");  ////   COUT(i);  ////   COUT(bootstrapA_0_t1);  //////   COUT(a);  ////   COUT(vol);  ////   COUT(bond);  ////   COUT("->");     ////   COUT(itheta);  //  }//i  //  
  const double __YEAR=365.;  const int __year=365;  const int __month=30;  const int __week=7;  std::vector<int> setYear;
  if(0>0){//option1 =====================================================   for (std::size_t i = 0; i < 5; ++i)   setYear.push_back(i*__week );   for (std::size_t i = 1; i < 12; ++i) setYear.push_back(i*__month);   //for (std::size_t i = 1; i < 10+1; ++i) setYear.push_back(i*__year /__year);   //// setYear.push_back( 10*__year /__year + 5./365);   for (std::size_t y = 1; y < 10; ++y)     for (std::size_t i = 0; i < 12; ++i)      setYear.push_back(y*__year + i*__month);  }else {//option2 =====================================================   for (std::size_t i = 0; i < 12; ++i) setYear.push_back(i*__month);   //for (std::size_t i = 1; i < 10+1; ++i) setYear.push_back(i*__year /__year);   //// setYear.push_back( 10*__year /__year + 5./365);   for (std::size_t y = 1; y < 10; ++y)     for (std::size_t i = 0; i < 12; ++i)      setYear.push_back(y*__year + i*__month);  }
  for (std::size_t i = 0; i < setYear.size()-1; ++i) {   pre::stepFunc iret(year,theta);    const double time1 = setYear.at(i+0)/__YEAR;    const double time2 = setYear.at(i+1)/__YEAR;   const double a  = this->_sa.getValue(time2);   const double vol= this->_svol.getValue(time1);//stepFunc.~~~~;   const double bond = disFac.at(setYear.at(i+1));//Reader.~~~~;   //COUT(disFac.at(i));   double _bootstrap_a_t0_t1(0);   double itheta = calibHWTheta_t1t2(    iret,     bond,    time1 ,    time2-time1,    10, //10 year    _bootstrap_a_t0_t1    );     //{//t1 bond is...   //double readT1Bond = disFac.at(setYear.at(i));//Reader.~~~~;   //const double t1Bond = std::exp(-1*_bootstrap_a_t0_t1 - this->_r0 * 1/a * (1-std::exp(-1*time1)) );   // COUT("Compare bond");   // COUT(readT1Bond);   // COUT(t1Bond);   //}
   //const double C_0_T2 = (1 - std::exp(-1 * a* time2 )) / a;   //const double bondT2 = DFs.at(i+1).second;   //bootstrapA_0_t1 = -1 * std::log(bondT2)  -1 * this->_r0 * C_0_T2;   theta.push_back(itheta);   year.push_back(time1);   vbondA.push_back(_bootstrap_a_t0_t1);  
   //   //   if(i>10) continue;   //   //if(i%100!=0) continue;   //   COUT("----");   //   COUT(i);   //   COUT(bootstrapA_0_t1);   ////   COUT(a);   //   COUT(vol);   //   COUT(bond);   //   COUT("->");      //   COUT(itheta);  }//i
 
  theta.push_back(theta.at(theta.size()-1));  year.push_back(year.at(year.size()-1));  pre::stepFunc ret(year,theta);
  vbondA.push_back(vbondA.at(vbondA.size()-1));  pre::stepFunc bondA2(year,vbondA);  _bondA = vbondA;
  return ret; }//stepFunc getHWTheta()
========================================================================================== const double IR::calibHWTheta_t1t2(  stepFunc& theta,  const double bondPrice_0_t2,  const double t1,  const double dt,  const double T,  double& _bootstrap_a_t0_t1  )  {  if(0==t1)return 0;  const double init=this->_r0;  const double a = this->_sa.getValue(t1);  //const double sigma_t1_t2 = this->_svol.getIntegralValue(t2) - this->_svol.getIntegralValue(t1)    (t2-t1);  //const double dt = t2 - t1;  const double t2 = t1 + dt;  const double dt1 = T - t1;  const double dt2 = T - t2;  const double sigma_t1_t2 = ( this->_svol.getValue(t2) + this->_svol.getValue(t1) ) / 2.;  if(t1==t2) return theta.getValue(T);
  _bootstrap_a_t0_t1 = this->calibHWa_t0t1(theta,T); // critical  const double C_0_T = (1 - std::exp(-1 * a*t2)) / a;  double sigmaPart = 1. / 2 * std::pow(sigma_t1_t2, 2) / a / a /2 /a;  sigmaPart *= std::exp(-2*a*dt2) -std::exp(-2*a*dt1) -4 * (std::exp(-1*a*dt2) - std::exp(-1*a*dt1))  +2*a*dt;
  const double RR = -1*std::log(bondPrice_0_t2) - init* C_0_T - _bootstrap_a_t0_t1 - sigmaPart;  const double denom = dt - ( std::exp(-1*a*dt2) - std::exp(-1*a*dt1) )/a;
  /* {  double C_0_t1 = (1 - std::exp(-1 * a*t1)) / a;  COUT( std::exp(-init* C_0_t1 - bootstrap_a_t0_t1));  }*/   return RR*a / denom; }==================================================================================================================================================================================================================================================================================================================================================================================================================================================================

const double IR::calibHWa_t0t1(  // estimate A(0,t1)   stepFunc& theta,  const double T  ) {  std::size_t numOfBootstrap = theta._theta.size();  const double a = this->_sa.getValue(10./365);
  double thetaBootstrap(0);  for(std::size_t i = 0; i+1 < numOfBootstrap ; ++i){   const double t1 = theta._a.at(i);   const double t2 = theta._a.at(i+1);      const double dt1 = T - t1;   const double dt2 = T - t2;   const double dt = t2 - t1;   const double isigma = this->_svol.getValue( t1 );   const double itheta = theta.getValue( t1 );
   double thetaPart = itheta / a ;   thetaPart *= dt - (std::exp(-a*dt2) - std::exp(-a*dt1))/a;   double volPart = -1 * isigma * isigma /4 / a / a / a ;   volPart *= std::exp(-2*a*dt2) - std::exp(-2*a*dt1) - 4*(std::exp(-a*dt2) - std::exp(-a*dt1)) +2*a*dt;

