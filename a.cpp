   public:   Price::CallPrice();   Price::PutPrice();      const double calcPrice();      private:    const int _callput;     const double Price::calcPrice(    return calcStandardPrice(_tau,_strike,_spot,_vol,r,_callput);  }      Price::CallPrice(const double& Expiry,     const double& Strike,   const double& Spot,   const double& Vol,   const double& r)   : _tau(Expiry), _strike(Strike),   _init(Spot), _vol(Vol), _r(r) , _callput(1)  {};  Price::PutPrice(const double& Expiry,     const double& Strike,   const double& Spot,   const double& Vol,   const double& r)   : _tau(Expiry), _strike(Strike),   _init(Spot), _vol(Vol), _r(r) , _callput(-1)  {};        const double Price::calcStandardPrice(    const double Expiry,   const double Strike,   const double Spot,   const double Vol,   const double r,   const string callput ) {     省略      const int CallPut = "call"==callput ? 1 : -1 ;    //double price = Spot*CDF( CallPut*dp)    // - std::exp(-1 * r * Expiry)*Strike*CDF(CallPut*dm);   //return price;   return 0;  }      const double Price::calcStandardPutPrice(    const double Expiry,   const double Strike,   const double Spot,   const double Vol,   const double r ) {   double price = calcStandardPrice(Expiry,Strike,Spot,Vol,r,"put");   return price;  }      const double Price::calcStandardCallPrice(    const double Expiry,   const double Strike,   const double Spot,   const double Vol,   const double r ) {   double price = calcStandardPrice(Expiry,Strike,Spot,Vol,r,"call");   return price;  }      const double Price::derivStrike(const double initStrike , const double precision) {     const double st1 = initStrike*(1 + precision/2);    const double st2 = initStrike*(1 - precision/2);    const double pv1 = calcStandardCallPrice(_tau, st1, _init, _vol, _r);    const double pv2 = calcStandardCallPrice(_tau, st2, _init, _vol, _r);    return (pv1-pv2)/precision;   };          const double Price::atmStrike(const double& initStrike , const double& precision) {    const size_t maxloop = 200;   double iiStrike = initStrike; // = _vol?   double calibratedStrike = 0;      for (size_t ii = 0; ii < maxloop; ++ii) {    const double price = calcStandardPrice(_tau, iiStrike, _init, _vol, _r,_callput);   const double deriv = this->derivStrike(iiStrike, precision);   double newVol = (targetPrice - price) / deriv + initVol;   if (std::fabs(newVol - iiVol) > precision) {    iiVol = newVol;   continue; //loop again  } else {    calibratedVol = iiVol;   break;  }  }//for   return calibratedVol;     };      //-----------------------------   //-----------------------------   //-----------------------------   template <T1,T2>   const std::map<T1,T2> mkt_to_integratedVol(const std::vector<T1,T2>& mktVol){    std::map<T1,T2> IntegratedVol;   double previousTenor=0;   double previousVol=0;      for (std::map<T1,T2>::iterator it = mktVol.begin(); it! = mktVol.end(); ++it)    T1 tenor = it->first;   T2 Vol = it->second;      double correctedVol = (Vol*tenor - previousVol*previousTenor) /(tenor-previousTenor);      IntegratedVol.insert(std::make_pair(tenor, correctedVol));   previousTenor=Tenor;   previousVol=Vol;     }//for i   return IntegratedVol;     } //      //-----------------------------   std::map<double,double> CaribVol(std::vector<double> vec){       std::map<double,double> tenorVol;   double tenor;   double Vol; //=price.Calibation();      for(std::size_t i=0; i<vec.size();++i){    tenorVol.insert(std::make_pair(tenor, Vol));  }      return tenorVol;  } //      //------------------------------------   template <T1,T2>   //template <class T1,class T2> ??   double VolIntegral( std::map<T1,T2> tenorVol , double now){    double IntegratedVol=0;      T1 previousTenor=0;   for (std::map<T1,T2>::iterator it = tenorVol.begin(); it! = tenorVol.end(); ++it)  // for(std::size_t i=0; i<tenorVol.size();++i){    T1 tenor = it->first;   if( !(now>tenor) )break;   T2 Vol = it->second;      IntegratedVol += (tenor-previousTenor)*Vol;   previousTenor=Tenor;  }//for i   return IntegratedVol;  }//         //------------------------------------   template <T1,T2>   double VolAtT(std::map<T1,T2> tenorVol , double now){       T1 previousVol=0;   for (std::map<T1,T2>::iterator it = tenorVol.begin(); it! = tenorVol.end(); ++it){    T1 tenor = it->first;   if( !(now>tenor) )break;   T2 Vol = it->second;   previousVol = Vol;  }   return previousVol;  }//   //------------------------------------         
